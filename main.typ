#import "templates/index.typ": *
#import "templates/utils.typ": *
#import "libs/tablex.typ": *

// Тут указываем только авторов [authors] и название работы [title] 
#show: index.with(authors: ("В.Д. Панков", ), title: [ОТЧЁТ О ПРАКТИКЕ])

// ch -- center heading
#ch("Введение")

Производственная практика проходила на предприятии ООО “ВАЛДАЙ РОБОТЫ”. Основной вид деятельности предприятия: «Производство промышленных роботов и робототехнических устройств»

Структура предприятия представлена на рисунке @org_structure.

#figure(
  image(ip("org_structure.png")),
  caption: "Структура организации"
) <org_structure>


Практика будет проходить в отделе разработки ПО, в подотделе разработки ПО высокого уровня.

Перед отделом стоят цели разработки автономной работы роботизированных устройств, а также разработки связанного с этим ПО, например, программ для операторов устройств.

Отдел не имеет фиксированных требований к конкретному программному обеспечению, что позволяет использовать наиболее подходящие инструменты для каждой задачи. В настоящий момент работа ведется с помощью следующих программ:

\1. Редактор исходного кода Visual Studio Code:

Описание: Популярный редактор с открытым исходным кодом, разработанный Microsoft.
Преимущества:

| Поддержка подсветки синтаксиса для различных языков программирования.

| Множество расширений, добавляющих дополнительные функции, такие как отладка, автодополнение кода и интеграция с системами контроля версий.

| Кроссплатформенность (доступен для Windows, macOS и Linux).
Использование: В отделе используется для написания кода на различных языках программирования, таких как C++, Python, JavaScript и Go.

\2. IDE Keil µVision:

Описание: Интегрированная среда разработки (IDE) для микроконтроллеров семейства ARM Cortex-M.
Преимущества:
| Встроенный компилятор, отладчик и симулятор.

| Поддержка различных отладочных инструментов, таких как J-Link и ULINK.

| Библиотека готовых к использованию программных модулей.

Использование: В отделе используется для разработки программного обеспечения для микроконтроллеров, используемых в различных проектах.

\3. Git:

Описание: Система контроля версий, позволяющая отслеживать изменения в файлах и коде.
Преимущества:

| Позволяет работать над проектами совместно с другими разработчиками.

| Помогает отслеживать историю изменений и откатывать к предыдущим версиям.

| Обеспечивает децентрализованное хранение кода.

Использование: В отделе используется для контроля версий исходного кода, документации и других файлов.
\4. Gitea:

Описание: Локальный Git-сервер, позволяющий хранить и управлять Git-репозиториями.
Преимущества:
| Позволяет работать с Git-репозиториями в локальной сети без доступа к интернету.

| Обеспечивает более высокий уровень безопасности и контроля над кодом.

| Прост в установке и использовании.

Использование: В отделе используется для хранения Git-репозиториев, доступ к которым требуется только сотрудникам отдела.

Задачей на производственную практику является разработка
требований к программным модулям, их интеграция, отладка и тестирование приложения по работе 
с картой в RMS (Robot Management System).

= Описание требование к программным модулям

Для уже разработанной информационной системы будет разработан дополнительный программный модуль для отображения карты в режиме реального времени.

В данном модуле необходимо реализовать:

| Размещение и настройка масштаба карты: посредством жестов, с помощью элементов управления и с помощью нативных контроллеров (например с помощью мыши);

| Корректное отображение проходимой и непроходимой зоны для робота.

| Корректная работа модуля на операционных системах: Windows, Linux, macOS, Android, а  также иметь реализацию в виде веб-приложения.


При этом должна обеспечиваться мультиплатформенность приложения и удобный визуальный и понятный интерфейс.

Данный модуль должен успешно работать с разработанными модулями:

| map_helper -- это приложение, представляющее собой REST-API для загрузки карты в map_server ROS2 посредством HTTP-запросов, что позволяет загружать карты извне. Для более удобной интеграции, необходимо доработать или изменить данный модуль.

| map_server ROS2 -- это приложение, которое помогает роботам, понимать своё положение пространстве и пространство в целом (куда они могут двигаться). 



= Интеграция программных модулей

== Построение UML-диаграммы компонентов ПП

На рисунке @components представлена UML-диаграмма компонентов информационной системы. 

Описание некоторых частей диаграммы:

map_kmp -- разрабатываемый модуль карты, который включает в себя общую часть кода, которая запускается на всех платформах (commonMain) нативные части:

| desktopMain -- код, который будет запускаться только на компьютере;

| wasmJsMain -- код, который будет запускаться только в веб-приложениями;

| androidMain -- код, который работает только на операционных системах Android.

На диаграмме жёлтым закрашены модули, которые будут разработаны и изменены для удобной интеграции в ходе выполнения задания практики. 

#rotate(-90deg, reflow: true)[
#figure(
  image(ip("components3.png")),
  caption: "Диаграмма компонентов"
) <components>
]


== Технологии, используемые для интеграции 
Для создания и интеграции разработанных модулей были использованы следующие инструменты.

ROS2 (Robot Operating System 2) - это следующее поколение гибкой и расширяемой платформы для разработки программного обеспечения роботов. Он предоставляет набор инструментов, библиотек и конвенций для управления роботами, включая коммуникацию между различными компонентами робота, управление устройствами, обработку данных сенсоров, планирование движения и многое другое.

Плюсы ROS2:

| Мультиплатформенность: ROS2 поддерживает различные операционные системы, такие как Linux, Windows и macOS, что позволяет разработчикам использовать их предпочитаемые операционные системы для разработки робототехнических приложений.

| Повышенная надежность: ROS2 предлагает улучшенную систему управления памятью, механизмы обработки ошибок и более надежные способы коммуникации между узлами, что способствует повышению стабильности и надежности робототехнических систем.

| Поддержка реального времени: В ROS2 внедрены механизмы, позволяющие управлять робототехническими системами в реальном времени, что делает его более подходящим для широкого спектра приложений, включая критичные по времени задачи.

| Улучшенная безопасность: ROS2 включает в себя механизмы аутентификации, авторизации и шифрования, что повышает уровень безопасности системы, особенно в контексте применения роботов в чувствительных областях, таких как медицина или автономные автомобили.

| Масштабируемость и расширяемость: ROS2 предлагает гибкую архитектуру, которая позволяет разработчикам создавать модульные системы, легко масштабируемые для различных типов роботов и задач.

| Активное сообщество: ROS2 поддерживается широким сообществом разработчиков и исследователей, что обеспечивает доступ к богатому набору инструментов, библиотек и документации, а также возможность сотрудничать и обмениваться знаниями с другими участниками сообщества. @ros2

ROSbridge - это программное обеспечение, которое обеспечивает коммуникацию между ROS (Robot Operating System) и другими системами и платформами через веб-интерфейс. Он предоставляет мост между ROS и веб-технологиями, позволяя взаимодействовать с робототехническими приложениями ROS через веб-интерфейс, включая веб-браузеры и приложения на различных платформах.

Плюсы ROSbridge:

| Универсальность: ROSbridge обеспечивает универсальное взаимодействие с системой ROS, позволяя использовать различные платформы и технологии для взаимодействия с робототехническими приложениями.

| Простота интеграции с веб-технологиями: ROSbridge упрощает интеграцию ROS с веб-технологиями, такими как HTML, JavaScript и WebSocket, что делает возможным управление и мониторинг роботов через интернет и веб-браузеры.

| Расширяемость: ROSbridge может быть расширен и адаптирован для поддержки различных протоколов и форматов данных, что делает его гибким инструментом для взаимодействия с различными системами и платформами.

| Поддержка множества приложений: ROSbridge позволяет создавать различные приложения, включая удаленное управление роботами, визуализацию данных, мониторинг и отладку, что делает его полезным инструментом для разработчиков и исследователей в области робототехники. @rosbridge

WebSockets - это протокол веб-коммуникации, который обеспечивает постоянное соединение между клиентом и сервером веб-приложения. Он позволяет двум сторонам взаимодействовать между собой, отправляя данные в реальном времени без необходимости постоянного обновления страницы.

Плюсы WebSockets:

| Двустороннее взаимодействие: WebSockets поддерживает двустороннюю связь между клиентом и сервером, что позволяет как клиенту, так и серверу отправлять и получать данные в режиме реального времени.

| Малая нагрузка на сеть: WebSockets использует одно постоянное соединение, что уменьшает нагрузку на сеть и снижает задержку в передаче данных по сравнению с традиционными HTTP-запросами.

| Низкая задержка: Поскольку соединение постоянно открыто, WebSockets обеспечивает низкую задержку и быстрое обновление данных между клиентом и сервером, что делает его идеальным для приложений, требующих мгновенной обратной связи.


Kotlin - это статически типизированный язык программирования, разработанный компанией JetBrains. Он предназначен для создания приложений как для JVM (Java Virtual Machine), так и для других платформ, включая Android, JavaScript, Native и другие.

Плюсы Kotlin:

| Безопасность типов: Kotlin предоставляет статическую типизацию, что помогает предотвратить ошибки типов во время компиляции. Это делает код более безопасным и надежным.

| Удобство синтаксиса: Синтаксис Kotlin чистый, лаконичный и более выразительный по сравнению с Java. Он уменьшает количество кода и делает его более читабельным.

| Null-безопасность: Kotlin имеет встроенную поддержку null-безопасности, что помогает предотвращать NullPointerException, что является распространенной проблемой в Java.

| Расширения функциональности: Kotlin предлагает множество улучшенных функций по сравнению с Java, таких как лямбда-выражения, расширения функций, инлайн-функции и многое другое, что способствует более эффективной разработке. @kotlin

Kotlin Multiplatform - это технология в языке программирования Kotlin, которая позволяет разработчикам создавать общий код, который может быть использован на различных платформах, таких как JVM, Android, iOS, JavaScript и другие. Суть Kotlin Multiplatform заключается в возможности разработки приложений с общим кодом, который можно использовать на различных целевых платформах, минимизируя дублирование кода и упрощая его поддержку. 

Плюсы Kotlin Multiplatform:

| Общий код: Kotlin Multiplatform позволяет разработчикам писать общий код для различных платформ, таких как JVM, Android, iOS и JavaScript, что сокращает время разработки и минимизирует дублирование кода.

| Улучшенная поддержка для множества платформ: Kotlin Multiplatform поддерживает широкий спектр платформ, включая мобильные устройства (Android и iOS), веб (JavaScript), серверные приложения (JVM) и другие, что делает его универсальным инструментом разработки.

| Интеграция с существующим кодом: Kotlin Multiplatform позволяет интегрировать общий код с существующими проектами на различных платформах, включая проекты на Java, Swift, Objective-C и JavaScript.


| Удобство использования средств разработки: Kotlin Multiplatform интегрируется с различными средствами разработки, такими как IntelliJ IDEA, Android Studio и Xcode, что обеспечивает удобство использования и отладки общего кода на различных платформах.

| Повышенная переносимость кода: Благодаря Kotlin Multiplatform разработчики могут создавать приложения с общим кодом, который можно легко переносить между различными платформами, что повышает гибкость и масштабируемость проектов. @kmp

IntelliJ IDEA - это интегрированная среда разработки (IDE) для языков программирования Java, Kotlin, Groovy, Scala, и других. Разработана компанией JetBrains и предоставляет разработчикам широкий набор инструментов для эффективной работы над проектами.

Плюсы IntelliJ IDEA:

| Мощный инструментарий: IntelliJ IDEA предоставляет широкий спектр инструментов для разработки, включая редактор кода с подсветкой синтаксиса, автодополнение, рефакторинг, отладчик, систему контроля версий и многое другое.

| Поддержка множества языков: Помимо Java, IntelliJ IDEA поддерживает также Kotlin, Groovy, Scala, JavaScript, TypeScript и другие языки программирования, что делает его универсальным инструментом для разработки различных типов приложений.

| Интеграция с фреймворками и технологиями: IntelliJ IDEA обладает интеграцией с популярными фреймворками и технологиями, такими как Spring, Hibernate, Android SDK, Maven, Gradle и другими, что упрощает создание и развертывание приложений.

| Удобство использования: Интерфейс IntelliJ IDEA интуитивно понятен и удобен в использовании, что позволяет разработчикам сосредотачиваться на написании кода, а не на поиске и настройке инструментов.

| Богатый набор плагинов: IntelliJ IDEA поддерживает богатый экосистему плагинов, которые позволяют расширить его функциональность и адаптировать под конкретные потребности разработчика. @idea

Jetpack Compose - это современная библиотека для разработки пользовательских интерфейсов (UI) на языке Kotlin для платформы Android. Она предоставляет декларативный подход к созданию пользовательских интерфейсов, что позволяет разработчикам описывать внешний вид приложения как набор компонентов и их свойств, а не через императивные последовательности операций.

Плюсы Jetpack Compose:

| Декларативный подход: Jetpack Compose использует декларативный подход к созданию пользовательских интерфейсов, что делает код более читабельным, понятным и легким в поддержке.

| Упрощение разработки: Благодаря декларативному подходу, Jetpack Compose значительно упрощает разработку пользовательских интерфейсов, сокращая количество кода, необходимого для описания интерфейса.

| Интерактивность и анимация: Jetpack Compose обеспечивает простое добавление интерактивности и анимации в пользовательские интерфейсы, что делает приложения более привлекательными для пользователей.

| Совместимость с существующим кодом: Jetpack Compose может быть легко интегрирован с существующим кодом на платформе Android, что позволяет постепенно внедрять его в существующие проекты.

| Поддержка разработки для различных устройств: Jetpack Compose предоставляет инструменты для создания адаптивных пользовательских интерфейсов, которые могут эффективно работать на различных устройствах и экранах.

| Совместимость с Android-стандартами: Jetpack Compose интегрируется с существующими инструментами и стандартами разработки Android, такими как Android Studio и AndroidX, что обеспечивает удобство использования и поддержки.

| Активная поддержка и развитие: Jetpack Compose активно поддерживается и развивается командой Google, что обеспечивает доступность к обновлениям, исправлениям ошибок и новым возможностям для разработчиков. @jetpack-compose

= Тестирование и отладка программных модулей

Тестирование программного обеспечения - это метод контроля качества ПО, направленный на:

| Выявление и исправление ошибок: поиск и устранение дефектов, влияющих на функциональность, производительность и безопасность ПО;

| Подтверждение соответствия требованиям: проверка соответствия ПО спецификациям, техническим заданиям и ожиданиям пользователей;

| Оценка надежности и производительности: измерение и анализ показателей производительности, таких как скорость работы, время отклика и потребление ресурсов.


В ходе интеграции, для более простой работы с модулем map_helper, были написаны UNIT-тесты для проверки корректной роботоспособности модуля. Код unit-тестов представлен в приложении Б.
На рисунке @complete представлено прохождение всех тестов.

#figure(
    image(ip("test_complete.png")),
    caption: "Пройденные тесты"
) <complete>

В ходе создании и его последующей интеграции модуля map_kmp, было проведено ручное тестирование. 
Аннотация к тестам приведена в таблице @anotation2.

#figure(
	table(columns: (1fr, 1fr),
	[Название проекта],[map_kmp],
	[Рабочая версия],[0.1],
	[Имя тестирующего], [Панков Василий Дмитриевич],
	[Дата теста], [27.03.2024]
	),
	caption: "Аннотация к тестам MapHelper",
) <anotation2>

Тесты приложения "MapHelper" представлены в таблице @tests2.

#pagebreak()

#figure(
    table(columns: (1.2fr, 1.3fr, 2fr, 3fr, 1.7fr, 1.7fr, 1.4fr),
	table.header([Тестовый пример №], [Приоритет тестирования], [Краткое изложение теста], 
	    [Этапы теста], [Ожидаемый результат], [Фактический результат], [Статус]),
	[ТП-01], [Высокий], [Запуск приложения на всех операционных системах], [
	    -- Запуск приложения на Android;
		
	    -- Запуск приложения на Linux;
	    
	    -- Запуск приложения в веб.
	],[Отображение карты на всех устройствах, как на рисунке @map_on_device],[Отображение карты на всех устройствах, как на рисунке @map_on_device],[Пройден],
	[ТП-02],[Средний] ,[Корректное обновление карты при её изменение на сервере], [Сменить карту с помощью map_helper], [Отображение карты на которую сменили], [Отображение карты на которую сменили], [Пройден],
	[ТП-03], [Высокий], [Перемещение с помощью жеста], [Потянуть за карту и переместить на определённый промежуток], [Перемещение на указанный промежуток], [Перемещение на указанный промежуток], [Пройден],
	[ТП-04], [Высокий],[Приближение карты с помощью двух жестов], [Приближение с помощью стандартного жеста двумя пальцами или с помощью колеса прокрутки], [Приближение на указанное расстояние],[Приближение на указанное расстояние],[Пройден],
	[ТП-05],
	[Средний],
	[Поворот карты с помощью жестов], 
	[
	    Повернуть карту с помощью жеста (двумя пальцами) или с помощью зажатия левой кнопки мыша
	],
	[Поворот в заданном направлении],
	[Поворот в заданном направлении],
	[Пройден],
	[ТП-06],
	[Высокий],
	[Корректное вычисление масштаба], 
	[
	    -- Загрузить карту с меткой в один метр;
	    -- Изменить масштаб на один метр;
	],
	[Линейка масштаба чётко совпадает с меткой],
	[Линейка масштаба чётко совпадает с меткой],
	[Пройден]
	),
	caption: "Проведённые ручные тесты над модулем map_kmp",
) <tests2>

#figure(
    image(ip("map_on_device.jpg"), height: 90%),
    caption: "Пройденные тесты"
) <map_on_device>

#ch("Заключение")

В ходе производственной практики был разработан и успешно интегрирован программный модуль для работы с картой "map_server" в системе ROS2, чей код представлен в приложении А. Полученный опыт включает в себя не только разработку, но и тестирование данного модуля, осуществленное с применением разнообразных подходов и инструментов, включая модульное тестирование с использованием языка программирования Kotlin, а также ручное тестирование функциональности созданного модуля.

В перспективе планируется дальнейшее развитие системы с добавлением функционала по загрузке карты напрямую через приложение, что позволит значительно расширить возможности и удобство использования системы. Этот процесс потребует дальнейшей работы над модулем, его оптимизацию и адаптацию к новым требованиям, что представляет собой интересный вызов для дальнейшего профессионального развития.


#ch("Список использованных источников")

#bibliography("bibliography.yml", title: none, full: true, style: "gost-r-705-2008-numeric")

#chn([ПРИЛОЖЕНИЕ А Листинг разработанного модуля])

#show raw: set text(hyphenate: false, size: 10pt)
#show raw: set par(justify: false, leading: 1em, first-line-indent: 0em)

androidMain/kotlin/Platform.android.kt

#raw(read("./src/app/androidMain/kotlin/Platform.android.kt"), lang: "kotlin")


androidMain/kotlin/utils/ImageManipulations.android.kt

#raw(read("src/app/androidMain/kotlin/utils/ImageManipulations.android.kt"), lang: "kotlin")


androidMain/kotlin/utils/Modifiers.android.kt

#raw(read("src/app/androidMain/kotlin/utils/Modifiers.android.kt"), lang: "kotlin")

androidMain/kotlin/su/pank/rmsui/MainActivity.kt

#raw(read("src/app/androidMain/kotlin/su/pank/rmsui/MainActivity.kt"), lang: "kotlin")

commonMain/kotlin/App.kt

#raw(read("src/app/commonMain/kotlin/App.kt"), lang: "kotlin")

commonMain/kotlin/Platform.kt

#raw(read("src/app/commonMain/kotlin/Platform.kt"), lang: "kotlin")

commonMain/kotlin/utils/ImageManipulations.kt

#raw(read("src/app/commonMain/kotlin/utils/ImageManipulations.kt"), lang: "kotlin")

commonMain/kotlin/utils/KoinIntegration.kt

#raw(read("src/app/commonMain/kotlin/utils/KoinIntegration.kt"), lang: "kotlin")

commonMain/kotlin/utils/Modifiers.kt

#raw(read("src/app/commonMain/kotlin/utils/Modifiers.kt"), lang: "kotlin")

commonMain/kotlin/ui/components/map/MapControllers.kt

#raw(read("src/app/commonMain/kotlin/ui/components/map/MapControllers.kt"), lang: "kotlin")

commonMain/kotlin/ui/components/map/MapState.kt

#raw(read("src/app/commonMain/kotlin/ui/components/map/MapState.kt"), lang: "kotlin")

commonMain/kotlin/ui/components/map/MapView.kt

#raw(read("src/app/commonMain/kotlin/ui/components/map/MapView.kt"), lang: "kotlin")

commonMain/kotlin/ui/di/uiModule.kt

#raw(read("src/app/commonMain/kotlin/ui/di/uiModule.kt"), lang: "kotlin")

commonMain/kotlin/ui/screens/main/MainScreen.kt

#raw(read("src/app/commonMain/kotlin/ui/screens/main/MainScreen.kt"), lang: "kotlin")

commonMain/kotlin/ui/screens/main/MainScreenModel.kt

#raw(read("src/app/commonMain/kotlin/ui/screens/main/MainScreenModel.kt"), lang: "kotlin")

commonMain/kotlin/domain/di/domainModule.kt

#raw(read("src/app/commonMain/kotlin/domain/di/domainModule.kt"), lang: "kotlin")

commonMain/kotlin/domain/SetImageColorsUseCase.kt

#raw(read("src/app/commonMain/kotlin/domain/SetImageColorsUseCase.kt"), lang: "kotlin")

commonMain/kotlin/data/RosClient.kt

#raw(read("src/app/commonMain/kotlin/data/RosClient.kt"), lang: "kotlin")

commonMain/kotlin/data/MapHelperRepository.kt

#raw(read("src/app/commonMain/kotlin/data/MapHelperRepository.kt"), lang: "kotlin")

commonMain/kotlin/data/MapLoaderRepository.kt

#raw(read("src/app/commonMain/kotlin/data/MapLoaderRepository.kt"), lang: "kotlin")

commonMain/kotlin/data/model/MapDTO.kt

#raw(read("src/app/commonMain/kotlin/data/model/MapDTO.kt"), lang: "kotlin")

commonMain/kotlin/data/model/ErrorDTO.kt

#raw(read("src/app/commonMain/kotlin/data/model/ErrorDTO.kt"), lang: "kotlin")

commonMain/kotlin/data/di/dataModule.kt

#raw(read("src/app/commonMain/kotlin/data/di/dataModule.kt"), lang: "kotlin")

desktopMain/kotlin/Platform.jvm.kt

#raw(read("src/app/desktopMain/kotlin/Platform.jvm.kt"), lang: "kotlin")

desktopMain/kotlin/main.kt

#raw(read("src/app/desktopMain/kotlin/main.kt"), lang: "kotlin")

desktopMain/kotlin/utils/Modifiers.desktop.kt

#raw(read("src/app/desktopMain/kotlin/utils/Modifiers.desktop.kt"), lang: "kotlin")

nonAndroidMain/kotlin/utils/ImageManipulations.nonAndroid.kt

#raw(read("src/app/nonAndroidMain/kotlin/utils/ImageManipulations.nonAndroid.kt"), lang: "kotlin")

wasmJsMain/kotlin/utils/Modifiers.wasmJs.kt

#raw(read("src/app/wasmJsMain/kotlin/utils/Modifiers.wasmJs.kt"), lang: "kotlin")

wasmJsMain/kotlin/Platform.wasmJs.kt

#raw(read("src/app/wasmJsMain/kotlin/Platform.wasmJs.kt"), lang: "kotlin")

wasmJsMain/kotlin/main.kt

#raw(read("src/app/wasmJsMain/kotlin/main.kt"), lang: "kotlin")

// #raw(read("./src/lib/Parser.kt"), lang: "kotlin")
\

//#allFiles(json("src/app.json").at(0)) 


#chn([ПРИЛОЖЕНИЕ Б Листинг разработанных UNIT-тестов])

// #show raw: set text(hyphenate: false, size: 10pt)
// #show raw: set par(justify: false, leading: 1em, first-line-indent: 0em)


MapHelperTest.kt

#raw(read("./src/tests/MapHelperTest.kt"), lang: "kotlin")

MapDTO.kt

#raw(read("./src/tests/MapDTO.kt"), lang: "kotlin")

ErrorDTO.kt

#raw(read("./src/tests/ErrorDTO.kt"), lang: "kotlin")

